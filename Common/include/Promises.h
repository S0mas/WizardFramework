#pragma once
#include <QObject>
#include <future>
#include <vector>

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @class	MyPromiseBoolVec
///
/// @brief	Custom promise adapter class to handle promise object with int as the data type.
///
/// @author	Krzysztof Sommerfeld
/// @date	03.02.2020
////////////////////////////////////////////////////////////////////////////////////////////////////

class MyPromiseInt : public QObject {
	Q_OBJECT
	std::promise<int> promise;
public:

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	auto MyPromiseInt::future() noexcept
	///
	/// @brief	Gets the future
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	///
	/// @returns	The future.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	auto future() noexcept {
		return promise.get_future();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	Q_INVOKABLE void MyPromiseInt::set(const int value) noexcept
	///
	/// @brief	Sets the future.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	///
	/// @param 	value	The new value.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	Q_INVOKABLE void set(const int value) noexcept {
		promise.set_value(value);
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @class	MyPromiseBoolVec
///
/// @brief	Custom promise adapter class to handle promise object with bool as the data type.
///
/// @author	Krzysztof Sommerfeld
/// @date	03.02.2020
////////////////////////////////////////////////////////////////////////////////////////////////////

class MyPromiseBool : public QObject {
	Q_OBJECT
	std::promise<bool> promise;
public:

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	auto MyPromiseBool::future() noexcept
	///
	/// @brief	Gets the future.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	///
	/// @returns	The future.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	auto future() noexcept {
		return promise.get_future();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	Q_INVOKABLE void MyPromiseBool::set(const bool value) noexcept
	///
	/// @brief	Sets the future.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	///
	/// @param 	value	The new value.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	Q_INVOKABLE void set(const bool value) noexcept {
		promise.set_value(value);
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @class	MyPromiseBoolVec
///
/// @brief	Custom promise adapter class to handle promise object with out the data.
///
/// @author	Krzysztof Sommerfeld
/// @date	03.02.2020
////////////////////////////////////////////////////////////////////////////////////////////////////

class MyPromiseVoid : public QObject {
	Q_OBJECT
	std::promise<void> promise;
public:

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	auto MyPromiseVoid::future() noexcept
	///
	/// @brief	Gets the future.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	///
	/// @returns	The future.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	auto future() noexcept {
		return promise.get_future();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	Q_INVOKABLE void MyPromiseVoid::set() noexcept
	///
	/// @brief	Sets the future.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	////////////////////////////////////////////////////////////////////////////////////////////////////

	Q_INVOKABLE void set() noexcept {
		promise.set_value();
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @class	MyPromiseBoolVec
///
/// @brief	Custom promise adapter class to handle promise object with std::vector<bool> as the data type.
///
/// @author	Krzysztof Sommerfeld
/// @date	03.02.2020
////////////////////////////////////////////////////////////////////////////////////////////////////

class MyPromiseBoolVec : public QObject {
	Q_OBJECT
	std::promise<std::vector<bool>> promise;
public:
	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	auto MyPromiseBoolVec::future() noexcept
	///
	/// @brief	Gets the future.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	03.02.2020
	///
	/// @returns	The future.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	auto future() noexcept {
		return promise.get_future();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	Q_INVOKABLE void MyPromiseBoolVec::set(const std::vector<bool>& value) noexcept
	///
	/// @brief	Sets the future.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	///
	/// @param 	value	The new value.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	Q_INVOKABLE void set(const std::vector<bool>& value) noexcept {
		promise.set_value(value);
	}
};