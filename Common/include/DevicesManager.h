#pragma once
#include "AbstractDevice.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @class	DevicesManager
///
/// @brief	Manager for the devices. Responsible to communicate with them and to forward signals from them.
///
/// @author	Krzysztof Sommerfeld
/// @date	04.02.2020
////////////////////////////////////////////////////////////////////////////////////////////////////

class DevicesManager : public QObject {
	Q_OBJECT
	std::vector<AbstractDevice*> devices_;
public:
	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	DevicesManager::DevicesManager(QObject* parent = nullptr) noexcept
	///
	/// @brief	Constructor
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	///
	/// @param [in]	parent	(Optional) If not null - will be set as constructed object parent. In the
	/// 					QObject tree.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	DevicesManager(QObject* parent = nullptr) noexcept : QObject(parent) {}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	DevicesManager::~DevicesManager() override = default;
	///
	/// @brief	Default destructor.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	////////////////////////////////////////////////////////////////////////////////////////////////////

	~DevicesManager() override = default;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	void DevicesManager::addDevice(AbstractDevice* device) noexcept;
	///
	/// @brief	Adds the device to the manager and takes its ownership.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	///
	/// @param [in]	device	Ptr to the device object.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	void addDevice(AbstractDevice* device) noexcept;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	AbstractDevice* DevicesManager::getDevice(const QString& nameId) noexcept;
	///
	/// @brief	Gets a device.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	///
	/// @param 	nameId	Identifier for the name.
	///
	/// @returns	Null if it there is no device with provided nameId, else the device ptr.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	AbstractDevice* getDevice(const QString& nameId) noexcept;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	const std::vector<AbstractDevice*>& DevicesManager::devices() const noexcept;
	///
	/// @brief	Gets the devices.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	///
	/// @returns	Vector of pointers to the devices.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	const std::vector<AbstractDevice*>& devices() const noexcept;
public slots:
	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	void DevicesManager::connectDevices() const noexcept;
	///
	/// @brief	Connects the devices.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	////////////////////////////////////////////////////////////////////////////////////////////////////

	void connectDevices() const noexcept;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	void DevicesManager::disconnectDevices() const noexcept;
	///
	/// @brief	Disconnects the devices.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	////////////////////////////////////////////////////////////////////////////////////////////////////

	void disconnectDevices() const noexcept;

signals:
	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	void DevicesManager::connectionProcedureCompleted() const;
	///
	/// @brief	Output signal. Indicates that the connection procedure has been completed.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	////////////////////////////////////////////////////////////////////////////////////////////////////

	void connectionProcedureCompleted() const;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	void DevicesManager::logMsg(const QString& msg) const;
	///
	/// @brief	Logs a message.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	///
	/// @param 	msg	The message.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	void logMsg(const QString& msg) const;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @fn	void DevicesManager::reportError(const QString& errorMsg) const;
	///
	/// @brief	Reports an error.
	///
	/// @author	Krzysztof Sommerfeld
	/// @date	04.02.2020
	///
	/// @param 	errorMsg	Message describing the error.
	////////////////////////////////////////////////////////////////////////////////////////////////////

	void reportError(const QString& errorMsg) const;
};
